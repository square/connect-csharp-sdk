/* 
 * Square Connect API
 *
 * Client library for accessing the Square Connect APIs
 *
 * OpenAPI spec version: 2.0
 * Contact: developers@squareup.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;

namespace Square.Connect.Model
{
    /// <summary>
    /// Defines how prices are modified or set for items that match the pricing rule during the active time period.
    /// Note: This endpoint is in beta.
    /// </summary>
    [DataContract]
    public partial class CatalogPricingRule :  IEquatable<CatalogPricingRule>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CatalogPricingRule" /> class.
        /// </summary>
        /// <param name="Name">User-defined name for the pricing rule. For example, \&quot;Buy one get one free\&quot; or \&quot;10% off\&quot;..</param>
        /// <param name="TimePeriodIds">A list of unique IDs for the catalog time periods when this pricing rule is in effect. If left unset, the pricing rule is always in effect..</param>
        /// <param name="DiscountId">Unique ID for the &#x60;CatalogDiscount&#x60; to take off the price of all matched items..</param>
        /// <param name="MatchProductsId">Unique ID for the &#x60;CatalogProductSet&#x60; that will be matched by this rule. A match rule matches within the entire cart. A match rule can match multiple times in the cart. If no &#x60;ProductSet&#x60; is present, the rule will match all products..</param>
        /// <param name="ApplyProductsId">[deprecated] __Deprecated__: Please use the &#x60;exclude_products_id&#x60; field to apply an exclude set instead. Exclude sets allow better control over quantity ranges and offer more flexibility for which matched items receive a discount.  &#x60;CatalogProductSet&#x60; to apply the pricing to. An apply rule matches within the subset of the cart that fits the match rules (the match set). An apply rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules..</param>
        /// <param name="ExcludeProductsId">&#x60;CatalogProductSet&#x60; to exclude from the pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules..</param>
        /// <param name="ValidFromDate">Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD)..</param>
        /// <param name="ValidFromLocalTime">Represents the local time the pricing rule should be valid from. Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated..</param>
        /// <param name="ValidUntilDate">Represents the date the Pricing Rule is valid until. Represented in RFC3339 full-date format (YYYY-MM-DD)..</param>
        /// <param name="ValidUntilLocalTime">Represents the local time the pricing rule should be valid until. Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated..</param>
        /// <param name="ExcludeStrategy">If an &#x60;exclude_products_id&#x60; was given, controls which subset of matched products is excluded from any discounts.  Default value: &#x60;LEAST_EXPENSIVE&#x60; See [ExcludeStrategy](#type-excludestrategy) for possible values.</param>
        public CatalogPricingRule(string Name = default(string), List<string> TimePeriodIds = default(List<string>), string DiscountId = default(string), string MatchProductsId = default(string), string ApplyProductsId = default(string), string ExcludeProductsId = default(string), string ValidFromDate = default(string), string ValidFromLocalTime = default(string), string ValidUntilDate = default(string), string ValidUntilLocalTime = default(string), string ExcludeStrategy = default(string))
        {
            this.Name = Name;
            this.TimePeriodIds = TimePeriodIds;
            this.DiscountId = DiscountId;
            this.MatchProductsId = MatchProductsId;
            this.ApplyProductsId = ApplyProductsId;
            this.ExcludeProductsId = ExcludeProductsId;
            this.ValidFromDate = ValidFromDate;
            this.ValidFromLocalTime = ValidFromLocalTime;
            this.ValidUntilDate = ValidUntilDate;
            this.ValidUntilLocalTime = ValidUntilLocalTime;
            this.ExcludeStrategy = ExcludeStrategy;
        }
        
        /// <summary>
        /// User-defined name for the pricing rule. For example, \&quot;Buy one get one free\&quot; or \&quot;10% off\&quot;.
        /// </summary>
        /// <value>User-defined name for the pricing rule. For example, \&quot;Buy one get one free\&quot; or \&quot;10% off\&quot;.</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }
        /// <summary>
        /// A list of unique IDs for the catalog time periods when this pricing rule is in effect. If left unset, the pricing rule is always in effect.
        /// </summary>
        /// <value>A list of unique IDs for the catalog time periods when this pricing rule is in effect. If left unset, the pricing rule is always in effect.</value>
        [DataMember(Name="time_period_ids", EmitDefaultValue=false)]
        public List<string> TimePeriodIds { get; set; }
        /// <summary>
        /// Unique ID for the &#x60;CatalogDiscount&#x60; to take off the price of all matched items.
        /// </summary>
        /// <value>Unique ID for the &#x60;CatalogDiscount&#x60; to take off the price of all matched items.</value>
        [DataMember(Name="discount_id", EmitDefaultValue=false)]
        public string DiscountId { get; set; }
        /// <summary>
        /// Unique ID for the &#x60;CatalogProductSet&#x60; that will be matched by this rule. A match rule matches within the entire cart. A match rule can match multiple times in the cart. If no &#x60;ProductSet&#x60; is present, the rule will match all products.
        /// </summary>
        /// <value>Unique ID for the &#x60;CatalogProductSet&#x60; that will be matched by this rule. A match rule matches within the entire cart. A match rule can match multiple times in the cart. If no &#x60;ProductSet&#x60; is present, the rule will match all products.</value>
        [DataMember(Name="match_products_id", EmitDefaultValue=false)]
        public string MatchProductsId { get; set; }
        /// <summary>
        /// __Deprecated__: Please use the &#x60;exclude_products_id&#x60; field to apply an exclude set instead. Exclude sets allow better control over quantity ranges and offer more flexibility for which matched items receive a discount.  &#x60;CatalogProductSet&#x60; to apply the pricing to. An apply rule matches within the subset of the cart that fits the match rules (the match set). An apply rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.
        /// </summary>
        /// <value>__Deprecated__: Please use the &#x60;exclude_products_id&#x60; field to apply an exclude set instead. Exclude sets allow better control over quantity ranges and offer more flexibility for which matched items receive a discount.  &#x60;CatalogProductSet&#x60; to apply the pricing to. An apply rule matches within the subset of the cart that fits the match rules (the match set). An apply rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.</value>
        [DataMember(Name="apply_products_id", EmitDefaultValue=false)]
        public string ApplyProductsId { get; set; }
        /// <summary>
        /// &#x60;CatalogProductSet&#x60; to exclude from the pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.
        /// </summary>
        /// <value>&#x60;CatalogProductSet&#x60; to exclude from the pricing rule. An exclude rule matches within the subset of the cart that fits the match rules (the match set). An exclude rule can only match once in the match set. If not supplied, the pricing will be applied to all products in the match set. Other products retain their base price, or a price generated by other rules.</value>
        [DataMember(Name="exclude_products_id", EmitDefaultValue=false)]
        public string ExcludeProductsId { get; set; }
        /// <summary>
        /// Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).
        /// </summary>
        /// <value>Represents the date the Pricing Rule is valid from. Represented in RFC3339 full-date format (YYYY-MM-DD).</value>
        [DataMember(Name="valid_from_date", EmitDefaultValue=false)]
        public string ValidFromDate { get; set; }
        /// <summary>
        /// Represents the local time the pricing rule should be valid from. Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
        /// </summary>
        /// <value>Represents the local time the pricing rule should be valid from. Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.</value>
        [DataMember(Name="valid_from_local_time", EmitDefaultValue=false)]
        public string ValidFromLocalTime { get; set; }
        /// <summary>
        /// Represents the date the Pricing Rule is valid until. Represented in RFC3339 full-date format (YYYY-MM-DD).
        /// </summary>
        /// <value>Represents the date the Pricing Rule is valid until. Represented in RFC3339 full-date format (YYYY-MM-DD).</value>
        [DataMember(Name="valid_until_date", EmitDefaultValue=false)]
        public string ValidUntilDate { get; set; }
        /// <summary>
        /// Represents the local time the pricing rule should be valid until. Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.
        /// </summary>
        /// <value>Represents the local time the pricing rule should be valid until. Represented in RFC3339 partial-time format (HH:MM:SS). Partial seconds will be truncated.</value>
        [DataMember(Name="valid_until_local_time", EmitDefaultValue=false)]
        public string ValidUntilLocalTime { get; set; }
        /// <summary>
        /// If an &#x60;exclude_products_id&#x60; was given, controls which subset of matched products is excluded from any discounts.  Default value: &#x60;LEAST_EXPENSIVE&#x60; See [ExcludeStrategy](#type-excludestrategy) for possible values
        /// </summary>
        /// <value>If an &#x60;exclude_products_id&#x60; was given, controls which subset of matched products is excluded from any discounts.  Default value: &#x60;LEAST_EXPENSIVE&#x60; See [ExcludeStrategy](#type-excludestrategy) for possible values</value>
        [DataMember(Name="exclude_strategy", EmitDefaultValue=false)]
        public string ExcludeStrategy { get; set; }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CatalogPricingRule {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  TimePeriodIds: ").Append(TimePeriodIds).Append("\n");
            sb.Append("  DiscountId: ").Append(DiscountId).Append("\n");
            sb.Append("  MatchProductsId: ").Append(MatchProductsId).Append("\n");
            sb.Append("  ApplyProductsId: ").Append(ApplyProductsId).Append("\n");
            sb.Append("  ExcludeProductsId: ").Append(ExcludeProductsId).Append("\n");
            sb.Append("  ValidFromDate: ").Append(ValidFromDate).Append("\n");
            sb.Append("  ValidFromLocalTime: ").Append(ValidFromLocalTime).Append("\n");
            sb.Append("  ValidUntilDate: ").Append(ValidUntilDate).Append("\n");
            sb.Append("  ValidUntilLocalTime: ").Append(ValidUntilLocalTime).Append("\n");
            sb.Append("  ExcludeStrategy: ").Append(ExcludeStrategy).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            return this.Equals(obj as CatalogPricingRule);
        }

        /// <summary>
        /// Returns true if CatalogPricingRule instances are equal
        /// </summary>
        /// <param name="other">Instance of CatalogPricingRule to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CatalogPricingRule other)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            if (other == null)
                return false;

            return 
                (
                    this.Name == other.Name ||
                    this.Name != null &&
                    this.Name.Equals(other.Name)
                ) && 
                (
                    this.TimePeriodIds == other.TimePeriodIds ||
                    this.TimePeriodIds != null &&
                    this.TimePeriodIds.SequenceEqual(other.TimePeriodIds)
                ) && 
                (
                    this.DiscountId == other.DiscountId ||
                    this.DiscountId != null &&
                    this.DiscountId.Equals(other.DiscountId)
                ) && 
                (
                    this.MatchProductsId == other.MatchProductsId ||
                    this.MatchProductsId != null &&
                    this.MatchProductsId.Equals(other.MatchProductsId)
                ) && 
                (
                    this.ApplyProductsId == other.ApplyProductsId ||
                    this.ApplyProductsId != null &&
                    this.ApplyProductsId.Equals(other.ApplyProductsId)
                ) && 
                (
                    this.ExcludeProductsId == other.ExcludeProductsId ||
                    this.ExcludeProductsId != null &&
                    this.ExcludeProductsId.Equals(other.ExcludeProductsId)
                ) && 
                (
                    this.ValidFromDate == other.ValidFromDate ||
                    this.ValidFromDate != null &&
                    this.ValidFromDate.Equals(other.ValidFromDate)
                ) && 
                (
                    this.ValidFromLocalTime == other.ValidFromLocalTime ||
                    this.ValidFromLocalTime != null &&
                    this.ValidFromLocalTime.Equals(other.ValidFromLocalTime)
                ) && 
                (
                    this.ValidUntilDate == other.ValidUntilDate ||
                    this.ValidUntilDate != null &&
                    this.ValidUntilDate.Equals(other.ValidUntilDate)
                ) && 
                (
                    this.ValidUntilLocalTime == other.ValidUntilLocalTime ||
                    this.ValidUntilLocalTime != null &&
                    this.ValidUntilLocalTime.Equals(other.ValidUntilLocalTime)
                ) && 
                (
                    this.ExcludeStrategy == other.ExcludeStrategy ||
                    this.ExcludeStrategy != null &&
                    this.ExcludeStrategy.Equals(other.ExcludeStrategy)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                if (this.Name != null)
                    hash = hash * 59 + this.Name.GetHashCode();
                if (this.TimePeriodIds != null)
                    hash = hash * 59 + this.TimePeriodIds.GetHashCode();
                if (this.DiscountId != null)
                    hash = hash * 59 + this.DiscountId.GetHashCode();
                if (this.MatchProductsId != null)
                    hash = hash * 59 + this.MatchProductsId.GetHashCode();
                if (this.ApplyProductsId != null)
                    hash = hash * 59 + this.ApplyProductsId.GetHashCode();
                if (this.ExcludeProductsId != null)
                    hash = hash * 59 + this.ExcludeProductsId.GetHashCode();
                if (this.ValidFromDate != null)
                    hash = hash * 59 + this.ValidFromDate.GetHashCode();
                if (this.ValidFromLocalTime != null)
                    hash = hash * 59 + this.ValidFromLocalTime.GetHashCode();
                if (this.ValidUntilDate != null)
                    hash = hash * 59 + this.ValidUntilDate.GetHashCode();
                if (this.ValidUntilLocalTime != null)
                    hash = hash * 59 + this.ValidUntilLocalTime.GetHashCode();
                if (this.ExcludeStrategy != null)
                    hash = hash * 59 + this.ExcludeStrategy.GetHashCode();
                return hash;
            }
        }

        public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
        { 
            yield break;
        }
    }

}
